<html lang="en-US">
<head>
  <link rel="stylesheet" href="../../../document.css"></link>
  <link rel="stylesheet" href="../../document.css"></link>
  <link rel="stylesheet" href="../document.css"></link>
  <link rel="stylesheet" href="document.css"></link>
  <title>M Language</title>
  </head>
<body>

<h1 class=page>The M Computer Language
  <br>Data Types</h1>
<p class=page>Last updated 15 June 2024</p>

<p>This chapter defines the syntax for describing data types.  Such data
type descriptions are used, for example, in <b>var</b> and <b>type</b>
statements.

<p>The data type specifications are:

<h2><tt>integer</tt> <i>[option ... option]</i></h2><indent>

  <p>Values of this data type can only be integers, within the range
  implied or specified by the optional parameters.

  <p>Operations on integers act as if intermediate values are infinitely
  wide, then all but the low N bits of the result used, where N is the
  number of logical bits in the destination integer. For example 255 + 1
  into an 8-bit unsigned integer results in 0, and 127 + 1 into an 8-bit
  signed integer results in -128.

  <p>All overflows and underflows are handled silently and are not
  considered errors.  There is no automatic saturation.

  <p>The optional sub-commands are:

  <h3><tt>signed</tt></h3><indent>

    <p>The integer will be signed.  The default is unsigned.

    <p>Unsigned integers are in ordinary binary (base 2) format. For
    example, all the possible values of a 3-bit unsigned integer are:

    <table>
      <thead>
        <tr>
          <th>&nbsp;Binary&nbsp;
          <th>&nbsp;Decimal value&nbsp;
        </thead>
      <tbody>
        <tr>
          <td>000
          <td>0
        <tr>
          <td>001
          <td>1
        <tr>
          <td>010
          <td>2
        <tr>
          <td>011
          <td>3
        <tr>
          <td>100
          <td>4
        <tr>
          <td>101
          <td>5
        <tr>
          <td>110
          <td>6
        <tr>
          <td>111
          <td>7
        </tbody>
      </table>

    <p>Signed integers are in twos-compliment binary format. For example,
    all the possible values of a 3-bit signed integer are:

    <table>
      <thead>
        <tr>
          <th>&nbsp;Binary&nbsp;
          <th>&nbsp;Decimal value&nbsp;
        </thead>
      <tbody>
        <tr>
          <td>100
          <td>-4
        <tr>
          <td>101
          <td>-3
        <tr>
          <td>110
          <td>-2
        <tr>
          <td>111
          <td>-1
        <tr>
          <td>000
          <td>0
        <tr>
          <td>001
          <td>1
        <tr>
          <td>010
          <td>2
        <tr>
          <td>011
          <td>3
        </tbody>
      </table>

    </p></indent><!-- end of INTEGER > SIGNED -->

  <h3><tt>bits</tt> <i>N</i></h3><indent>

    <p>The integer must be at least <i>N</i> bits wide. Implementations
    are allowed to use more bits if that maps more efficiently to the
    target hardware.

    <p>For example, on an 8-bit microcontroller <tt>integer bits 8</tt>
    would likely be implemented as a single 8-bit byte, whereas
    <tt>integer bits 12</tt> may be implemented as two 8-bit bytes (16
    bits).

    <p>The default is the size integer that maps most directly (and
    therefore results in the most efficient operations) to the target
    hardware.  The default integer size must be specified for each target
    implementation.

    </p></indent><!-- end of INTEGER > BITS -->

  <h3><tt>bitsexact</tt> <i>N</i></h3><indent>

    <p>The integer must act as if it were exactly <i>N</i> bits wide.
    Unless data structures are explicitly packed to use the minimum
    possible bits, implementations are allowed to use more bits of storage
    than <i>N</i>.  However, operations and resulting values must be as if
    the integer were exactly <i>N</i> bits wide.

    <p>For example on a 8-bit microcontroller, <tt>integer bitsexact
    6</tt> may be stored in a whole 8-bit byte, but can only take on
    values of 0 to 63.  Adding 1 to such an integer with a starting value
    of 63 results in 0, even if there are more bits of storage so that 64
    could have been represented.

    <p>This option guarantees integers act identically across different
    target processors, at the possible expense of additional operations
    when the specified size does not match a size the hardware can
    manipulate natively.

    <p>The default is the size integer that maps most directly (and
    therefore results in the most efficient operations) to the target
    hardware.  The default integer size must be specified for each target
    implementation.

    </p></indent><!-- end of INTEGER > BITSEXACT -->

  </p></indent><!-- end of INTEGER -->


<hr><!-- ---------------------------------------------------------------------->

<ul>
  <li><a rel="next" href="var.htm">Next chapter</a>
  <li><a rel="prev" href="memory.htm">Previous chapter</a>
  <li><a rel="contents" href="index.htm#contents">Table of Contents</a>
  <li><a rel="start" href="index.htm">First page</a>
  </ul>

</body></html>
